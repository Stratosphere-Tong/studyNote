
# c++
## 文件IO
* 输入输出至文件中的头文件
  +  \#include<fstream\>
* cerr流对象
  +   类osteam的对象，与标准错误输出设备连在一起。 cerr的作用是 向控制台(显示器)显示出错信息。对象cerr的输出是非缓冲输出，也就是说插入到cerr中的输出会被立即显示出来，非缓冲输出可迅速把出错信息告诉用户。
* clog流对象
  +  类ostream的对象，与标准错误输出设备连在一起。对象clog的输出是缓冲输出。即每次插入clog可能使其输出保持在缓冲区，要等缓冲区刷新时才输出。
* 输出指向字符串的指针的地址
  > cout<<(void*)ptr  ——强制类型转换
* write 函数的无格式输出
  + 调用成员函数write可实现无格式输出。它有两个参数。第一个参数是一个`指向字符的指针`，第二个参数是一个整型值。这个函数把`一定量的字节`从字符数组中输出。这些字节都是未经任何格式化的，仅仅是以原始数据形式输出。
* 输出流>>
  1. 流读取运算符通常会`跳过`输入流中的空格、tab键、换行符等空白字符。
  2. 当遇到输入流中的文件结束符时，流读取运算符返回0(false);否则，流读取运算符返回对调用该运算符的对象的引用。流读取运算符在读入EOF时返回0的特性使得它经常被用作为循环的判别条件，以避免选择特定的表示输入结束的值
* __get成员函数__
  1. 参数分别是接收字符的`字符数组`、字符数组的`大小`和`分隔符`(默认值为‘\n’)。
  2. 函数或者在读取比指定的最大字符数少一个字符后结束，或者在遇到分隔符时结束。为使字符数组(被程序用作缓冲区)中的输入字符串能够结束，空字符会被插入到字符数组中。函数不把分隔符放到字符数组中，但是分隔符仍然会`保留`在输入流中。
* __read成员函数__
  1. 调用成员函数read(char*,int)可实现无格式输入。它有两个参数。第一个参数是一个指向字符的`指针`，第二个参数是一个整型值。这个函数把`一定量的字节`从输入缓冲区读入字符数组，不管这些字节包含的是什么内容。
  2. 如果还没有读到指定的字符数，遇到了EOF，则读操作结束。此时可以用成员函数gcount统计输入的字符个数
* _ASCALL_ 文件和 _二进制文件_
   + ASCII文件也被称为文本文件，它将文件中的每个字节看成是一个字符的ASCII值。
   + 二进制文件是指将文件中的每个字节仅看成是一个二进制比特串。由程序解释比特串的含义。如果要将二进制文件中的比特串0000 0000 0000 0000 1111 1111 1111 1111解释成一个整型数，可以将这4个字节读入一个整型变量，C++就将这4个字节看成是一个整型数。
* 文件打开示例
  ![](.\文件打开模式.png)
  
  ``文件打开``
  ![](.\文件打开.png)
  ``文件关闭``
    
    ```outfile.close()```
  ![](.\文件关闭.png)
## __随机访问文件__
1.  成员函数及其用法
   ![](.\随机访问.png)
     
    ![](.\seekg&seekp.png)
2. 对于大型文件，数据的存储应该要求固定记录数据的长度，这样才能做到修改单点值不会影响到其他数据的存储。
    
    **做法**
      
      使用二进制形式读写
      ![](.\二进制文件的读写.png)

      __示例__
        
      ![](.\二进制文件数据大小.png)
    
    seekp 修改写指针  seekg 修改读指针

3. 二进制文件遍历的退出
    
    ```
    /*
    注意peek()函数指不改变读指针读取下一个字符

    如果单纯使用eof()函数会遇到最后一个结构体读取两遍的结果
    因为:  
      最后一行空行也会进入循环，导致读取错误。读取错误结果就是重新返回上一个读取结果。 
    因此可以利用peek()方法来避免这个问题：
    */
    while(!io.eof()&&io.peek()!=EOF)
    {
      ...
    }
    ```
## throw && catch 异常抛出   
1. __语法__
    ```
    try{
      可能抛出的异常代码
    }
    catch(类型1 参数1){处理方式1}
    catch(类型2 参数2){处理方式2}
    ……
    catch(...){捕获所有异常}
    ```
    ``注：抛出的异常不一定是对象，可以还是一个结果为内置类型的表达式``  
2. __栈展开__  
   ![](.\栈展开.png)
3. __异常规格__  
   ```
   void f() throw(类型1,类型2)
   //表明函数可能抛出的异常类型
   
   void f() throw()
   //表明函数不会抛出任何异常
   ```  
## 容器和迭代器
1. concept  
   迭代器对象相当于指向容器中对象的指针。一般作为容器的友元或者内嵌类。


